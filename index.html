<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Basic viewport meta, might be ignored but good practice -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kindle Sudoku</title>
    <style>
        /* Basic Reset & High Contrast Body */
        body {
            font-family: sans-serif;
            margin: 5px;
            padding: 0;
            background-color: white;
            color: black;
            /* Prevent text selection interfering with taps */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Centering Container */
        .container {
            text-align: center;
            max-width: 350px; /* Limit width */
            margin: 0 auto;
        }

        h1 {
            font-size: 18px;
            margin: 5px 0;
        }

        /* Sudoku Grid Table */
        #sudoku-grid {
            border-collapse: collapse;
            margin: 10px auto;
            border: 2px solid black; /* Outer border */
        }

        #sudoku-grid td {
            border: 1px solid #aaa; /* Lighter inner borders */
            width: 28px;  /* Adjust size as needed for touch */
            height: 28px; /* Adjust size as needed for touch */
            text-align: center;
            vertical-align: middle;
            font-size: 16px;
            cursor: default; /* Default cursor */
        }

        /* Classes for thicker 3x3 box borders */
        .thick-border-top { border-top: 2px solid black !important; }
        .thick-border-bottom { border-bottom: 2px solid black !important; }
        .thick-border-left { border-left: 2px solid black !important; }
        .thick-border-right { border-right: 2px solid black !important; }

        /* Cell Styling */
        .cell-given {
            font-weight: bold;
            background-color: #eee; /* Slightly different bg for given numbers */
        }

        .cell-editable {
            cursor: pointer; /* Pointer only for editable cells */
            color: #333; /* User input color */
        }

        .cell-selected {
            background-color: #ccc !important; /* Highlight selected cell */
        }

        .cell-error {
            background-color: #fcc !important; /* Simple error indication (might just look grey) */
            color: black !important;
        }

        /* Controls Area */
        .controls, .input-panel, .actions {
            margin: 10px 0;
        }

        /* Buttons & Select */
        button, select {
            font-size: 14px;
            padding: 6px 10px;
            margin: 3px;
            min-width: 40px; /* Ensure decent tap size */
            border: 1px solid black;
            background-color: #eee;
            cursor: pointer;
        }

        button:active, select:active {
             background-color: #ccc; /* Basic active state feedback */
        }

        .input-panel button {
            width: 30px; /* Smaller number buttons */
            height: 30px;
            padding: 2px;
        }

        /* Message Area */
        #message {
            margin-top: 10px;
            font-size: 14px;
            min-height: 1.2em; /* Reserve space */
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Kindle Sudoku</h1>

        <div class="controls">
            <label for="difficulty">Difficulty:</label>
            <select id="difficulty">
                <option value="easy">Easy (35-40 given)</option>
                <option value="medium" selected>Medium (30-34 given)</option>
                <option value="hard">Hard (25-29 given)</option>
                <!-- <option value="expert">Expert (20-24 given)</option> --> <!-- Might be too slow -->
            </select>
            <button onclick="startGame()">New Game</button>
        </div>

        <div id="message">Select difficulty and start a new game.</div>

        <table id="sudoku-grid">
            <!-- Grid will be generated here by JavaScript -->
        </table>

        <div class="input-panel">
            <strong>Input:</strong><br>
            <button onclick="inputNumber(1)">1</button>
            <button onclick="inputNumber(2)">2</button>
            <button onclick="inputNumber(3)">3</button>
            <button onclick="inputNumber(4)">4</button>
            <button onclick="inputNumber(5)">5</button>
            <button onclick="inputNumber(6)">6</button>
            <button onclick="inputNumber(7)">7</button>
            <button onclick="inputNumber(8)">8</button>
            <button onclick="inputNumber(9)">9</button>
            <button onclick="clearNumber()">Clear</button>
        </div>

        <div class="actions">
            <button onclick="checkSolution()">Check Puzzle</button>
        </div>
    </div>

    <script type="text/javascript">
        // --- Sudoku Logic (ES3 Compatible) ---

        var SIZE = 9;
        var BOX_SIZE = 3;

        var currentPuzzle = null; // The initial puzzle board (0 for empty)
        var currentSolution = null; // The complete solution
        var userBoard = null; // The board reflecting user input

        var selectedCell = { row: -1, col: -1, element: null }; // Track selected cell

        var difficultySettings = {
            'easy': 40,   // Number of cells to REMOVE (approx 41-46 clues left)
            'medium': 46, // Approx 35-40 clues left
            'hard': 51,   // Approx 30-34 clues left
            'expert': 56  // Approx 25-29 clues left (Might be too slow to generate reliably)
        };

        // --- Utility Functions ---

        // Fisher-Yates (Knuth) Shuffle (ES3 compatible)
        function shuffleArray(array) {
            var currentIndex = array.length, temporaryValue, randomIndex;
            // While there remain elements to shuffle...
            while (0 !== currentIndex) {
                // Pick a remaining element...
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex -= 1;
                // And swap it with the current element.
                temporaryValue = array[currentIndex];
                array[currentIndex] = array[randomIndex];
                array[randomIndex] = temporaryValue;
            }
            return array;
        }

        // Create an empty 9x9 board
        function createEmptyBoard() {
            var board = [];
            for (var r = 0; r < SIZE; r++) {
                board[r] = [];
                for (var c = 0; c < SIZE; c++) {
                    board[r][c] = 0;
                }
            }
            return board;
        }

        // Copy a board
        function copyBoard(board) {
            var newBoard = [];
            for (var r = 0; r < SIZE; r++) {
                newBoard[r] = [];
                for (var c = 0; c < SIZE; c++) {
                    newBoard[r][c] = board[r][c];
                }
            }
            return newBoard;
        }

        // --- Core Sudoku Logic ---

        // Find the next empty cell (0)
        function findEmpty(board) {
            for (var r = 0; r < SIZE; r++) {
                for (var c = 0; c < SIZE; c++) {
                    if (board[r][c] === 0) {
                        return { row: r, col: c };
                    }
                }
            }
            return null; // No empty cells
        }

        // Check if a number is valid in a given position
        function isValid(board, row, col, num) {
            // Check row
            for (var c = 0; c < SIZE; c++) {
                if (board[row][c] === num && c !== col) {
                    return false;
                }
            }
            // Check column
            for (var r = 0; r < SIZE; r++) {
                if (board[r][col] === num && r !== row) {
                    return false;
                }
            }
            // Check 3x3 box
            var boxStartRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
            var boxStartCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
            for (var r = 0; r < BOX_SIZE; r++) {
                for (var c = 0; c < BOX_SIZE; c++) {
                    if (board[boxStartRow + r][boxStartCol + c] === num && (boxStartRow + r !== row || boxStartCol + c !== col)) {
                        return false;
                    }
                }
            }
            return true; // Number is valid
        }

        // Backtracking solver (fills the board)
        // Returns true if solved, false otherwise
        function solveSudoku(board) {
            var emptyPos = findEmpty(board);
            if (!emptyPos) {
                return true; // Board is full, solved!
            }
            var row = emptyPos.row;
            var col = emptyPos.col;

            var nums = shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]); // Randomize numbers

            for (var i = 0; i < nums.length; i++) {
                var num = nums[i];
                if (isValid(board, row, col, num)) {
                    board[row][col] = num;
                    if (solveSudoku(board)) {
                        return true; // Found a solution
                    }
                    board[row][col] = 0; // Backtrack
                }
            }
            return false; // No valid number found for this cell
        }

        // --- Puzzle Generation ---

        function generatePuzzle(difficulty) {
            setMessage("Generating puzzle... (may take a while)");

            // Use setTimeout to allow the message to render before heavy computation
            setTimeout(function() {
                // 1. Create a fully solved board
                currentSolution = createEmptyBoard();
                if (!solveSudoku(currentSolution)) {
                     // This should ideally not happen with a proper backtracking start
                     setMessage("Error: Failed to generate a solution.");
                     return;
                }

                // 2. Create the puzzle by removing cells
                currentPuzzle = copyBoard(currentSolution);
                var cellsToRemove = difficultySettings[difficulty] || difficultySettings['medium'];
                var attempts = cellsToRemove * 2; // Limit attempts to prevent infinite loops
                var removed = 0;

                while (removed < cellsToRemove && attempts > 0) {
                    var r = Math.floor(Math.random() * SIZE);
                    var c = Math.floor(Math.random() * SIZE);

                    if (currentPuzzle[r][c] !== 0) {
                        // Basic removal - NOTE: Does NOT guarantee a unique solution for performance reasons on Kindle
                        currentPuzzle[r][c] = 0;
                        removed++;
                    }
                    attempts--;
                }

                // Ensure a minimum number of clues if too many removals failed (unlikely but possible)
                var remainingClues = 0;
                for(var r=0; r<SIZE; r++) {
                    for(var c=0; c<SIZE; c++) {
                        if(currentPuzzle[r][c] !== 0) remainingClues++;
                    }
                }
                var minClues = SIZE * SIZE - (cellsToRemove + 5); // Ensure slightly more than minimum expected
                if(remainingClues < minClues){
                    // If too few clues, it might mean generation was odd. Start over (simple recovery)
                    // Or, more simply for Kindle, just accept the easier puzzle.
                    // console.log("Warning: Fewer clues than expected. Puzzle might be easier.");
                }


                // 3. Initialize user board
                userBoard = copyBoard(currentPuzzle);

                // 4. Render the board
                renderBoard();
                setMessage("New game started. Select a cell to input numbers.");
                clearSelection();

            }, 50); // Small delay (50ms)
        }

        // --- UI Rendering ---

        function renderBoard() {
            var table = document.getElementById('sudoku-grid');
            table.innerHTML = ''; // Clear previous grid

            for (var r = 0; r < SIZE; r++) {
                var tr = document.createElement('tr');
                for (var c = 0; c < SIZE; c++) {
                    var td = document.createElement('td');
                    var val = userBoard[r][c];
                    td.innerHTML = val === 0 ? '' : val.toString();

                    // Add base class for potential styling
                    td.className = 'cell';

                    // Add classes for thick borders
                    if (r === 0) td.className += ' thick-border-top';
                    if ((r + 1) % BOX_SIZE === 0 && r !== SIZE - 1) td.className += ' thick-border-bottom';
                    if (c === 0) td.className += ' thick-border-left';
                    if ((c + 1) % BOX_SIZE === 0 && c !== SIZE - 1) td.className += ' thick-border-right';
                     // Ensure outer border aligns with table border
                    if (r === SIZE - 1) td.className += ' thick-border-bottom';
                    if (c === SIZE - 1) td.className += ' thick-border-right';


                    if (currentPuzzle[r][c] !== 0) {
                        // Given number - not editable
                        td.className += ' cell-given';
                    } else {
                        // Empty cell - editable
                        td.className += ' cell-editable';
                        // Add onclick handler using a closure to capture r, c, and td
                        td.onclick = (function(row, col, element) {
                            return function() {
                                selectCell(row, col, element);
                            };
                        })(r, c, td);
                    }
                    tr.appendChild(td);
                }
                table.appendChild(tr);
            }
        }

        // --- UI Interaction ---

        function setMessage(msg) {
            document.getElementById('message').innerHTML = msg;
        }

        function clearSelection() {
             if (selectedCell.element) {
                // Remove 'cell-selected' class robustly
                selectedCell.element.className = selectedCell.element.className.replace(/\bcell-selected\b/g, '');
            }
            selectedCell.row = -1;
            selectedCell.col = -1;
            selectedCell.element = null;
        }

        function selectCell(row, col, element) {
            if (!userBoard || currentPuzzle[row][col] !== 0) return; // Only select editable cells

            clearSelection(); // Clear previous selection

            selectedCell.row = row;
            selectedCell.col = col;
            selectedCell.element = element;
            element.className += ' cell-selected'; // Add selected class
            // Optionally clear message or provide input hint
            // setMessage("Enter number (1-9) or Clear");
        }

        function inputNumber(num) {
            if (selectedCell.row === -1 || !selectedCell.element) {
                setMessage("Please select an empty cell first.");
                return;
            }
             if (currentPuzzle[selectedCell.row][selectedCell.col] !== 0) {
                setMessage("Cannot change initial puzzle numbers.");
                return; // Cannot change given numbers
            }

            var r = selectedCell.row;
            var c = selectedCell.col;

            // Check if number is potentially valid (doesn't violate rules immediately)
            // We don't use the full solution check here, just immediate rule violation
            var tempBoard = copyBoard(userBoard);
            tempBoard[r][c] = num; // Temporarily place number
            if (!isValid(tempBoard, r, c, num)) {
                 // Optional: Provide immediate feedback, though checkSolution is the main validator
                 // setMessage("Number conflicts with another cell.");
                 // return; // Or allow input and let checkSolution handle it
            }

            userBoard[r][c] = num;
            selectedCell.element.innerHTML = num.toString();
             // Remove error class if present
            selectedCell.element.className = selectedCell.element.className.replace(/\bcell-error\b/g, '');

            // Optional: Automatically move to next empty cell? (might be complex/annoying on touch)
        }

        function clearNumber() {
            if (selectedCell.row === -1 || !selectedCell.element) {
                 setMessage("Please select an empty cell first.");
                 return;
            }
             if (currentPuzzle[selectedCell.row][selectedCell.col] !== 0) {
                 setMessage("Cannot clear initial puzzle numbers.");
                return; // Cannot change given numbers
            }

            userBoard[selectedCell.row][selectedCell.col] = 0;
            selectedCell.element.innerHTML = '';
             // Remove error class if present
            selectedCell.element.className = selectedCell.element.className.replace(/\bcell-error\b/g, '');
        }

        function checkSolution() {
            if (!userBoard) {
                setMessage("Start a new game first.");
                return;
            }

            var errorsFound = false;
            var isComplete = true;
            var table = document.getElementById('sudoku-grid');
            var rows = table.getElementsByTagName('tr');

            // Clear previous errors
            var cells = table.getElementsByTagName('td');
             for (var i = 0; i < cells.length; i++) {
                 cells[i].className = cells[i].className.replace(/\bcell-error\b/g, '');
             }


            for (var r = 0; r < SIZE; r++) {
                for (var c = 0; c < SIZE; c++) {
                    var cellValue = userBoard[r][c];
                    var tdElement = rows[r].getElementsByTagName('td')[c];

                    if (cellValue === 0) {
                        isComplete = false;
                        // Optionally highlight empty cells during check? Maybe not needed.
                    } else if (currentPuzzle[r][c] === 0) { // Only check user-entered numbers
                         // Temporarily remove the number to validate against others
                         userBoard[r][c] = 0;
                         if (!isValid(userBoard, r, c, cellValue)) {
                             errorsFound = true;
                             tdElement.className += ' cell-error';
                         }
                         // Put the number back
                         userBoard[r][c] = cellValue;
                    }
                }
            }

            if (errorsFound) {
                setMessage("Errors found (marked). Keep trying!");
            } else if (!isComplete) {
                setMessage("Looking good so far, but not complete yet.");
            } else {
                // Double check against the original solution for absolute correctness
                var correct = true;
                for(var r=0; r<SIZE; r++){
                    for(var c=0; c<SIZE; c++){
                        if(userBoard[r][c] !== currentSolution[r][c]){
                            correct = false;
                            break;
                        }
                    }
                     if(!correct) break;
                }
                if(correct){
                     setMessage("Congratulations! Puzzle Solved Correctly!");
                } else {
                    // This case should technically not be reached if isValid checks are correct
                    // and generation worked, but include as a fallback.
                     setMessage("Puzzle complete, but some numbers are incorrect.");
                     errorsFound = true; // Mark as error state
                     // Re-run validation highlighting based on solution (more intensive) - skip for kindle?
                }

            }
        }

        // --- Game Initialization ---

        function startGame() {
            var difficultySelect = document.getElementById('difficulty');
            var selectedDifficulty = difficultySelect.options[difficultySelect.selectedIndex].value;
            generatePuzzle(selectedDifficulty);
        }

        // Initial setup message on load
        window.onload = function() {
             // Render an empty grid initially or wait for New Game?
             // Let's wait for New Game to avoid confusion.
             setMessage("Select difficulty and press 'New Game'.");

             // Try rendering an empty placeholder grid? Might look better than nothing.
             // For simplicity, let's keep it blank until 'New Game' is pressed.
        };

    </script>

</body>
</html>